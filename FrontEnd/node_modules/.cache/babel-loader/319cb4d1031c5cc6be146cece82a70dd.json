{"ast":null,"code":"'use strict';\n\nconst Duplex = require('stream').Duplex;\n\nconst BufferList = require('bl');\n\nconst MongoParseError = require('../core/error').MongoParseError;\n\nconst decompress = require('../core/wireprotocol/compression').decompress;\n\nconst Response = require('../core/connection/commands').Response;\n\nconst BinMsg = require('../core/connection/msg').BinMsg;\n\nconst MongoError = require('../core/error').MongoError;\n\nconst OP_COMPRESSED = require('../core/wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nconst OP_MSG = require('../core/wireprotocol/shared').opcodes.OP_MSG;\n\nconst MESSAGE_HEADER_SIZE = require('../core/wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nconst COMPRESSION_DETAILS_SIZE = require('../core/wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\n\nconst opcodes = require('../core/wireprotocol/shared').opcodes;\n\nconst compress = require('../core/wireprotocol/compression').compress;\n\nconst compressorIDs = require('../core/wireprotocol/compression').compressorIDs;\n\nconst uncompressibleCommands = require('../core/wireprotocol/compression').uncompressibleCommands;\n\nconst Msg = require('../core/connection/msg').Msg;\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n */\n\nclass MessageStream extends Duplex {\n  constructor(options) {\n    options = options || {};\n    super(options);\n    this.bson = options.bson;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new BufferList();\n  }\n\n  _write(chunk, _, callback) {\n    const buffer = this[kBuffer];\n    buffer.append(chunk);\n\n    while (buffer.length >= 4) {\n      const sizeOfMessage = buffer.readInt32LE(0);\n\n      if (sizeOfMessage < 0) {\n        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n        return;\n      }\n\n      if (sizeOfMessage > this.maxBsonMessageSize) {\n        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${this.maxBsonMessageSize}`));\n        return;\n      }\n\n      if (sizeOfMessage > buffer.length) {\n        callback();\n        return;\n      }\n\n      const messageBuffer = buffer.slice(0, sizeOfMessage);\n      buffer.consume(sizeOfMessage);\n      processMessage(this, messageBuffer, callback);\n    }\n  }\n\n  _read()\n  /* size */\n  {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;\n\n    if (!shouldCompress || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    } // otherwise, compress the message\n\n\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n    compress({\n      options: operationDescription\n    }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err) {\n        operationDescription.cb(err, null);\n        return;\n      } // Create the msgHeader of OP_COMPRESSED\n\n\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n      // Create the compression details of OP_COMPRESSED\n\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n      compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n\n} // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\n\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processMessage(stream, message, callback) {\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  const responseOptions = stream.responseOptions;\n\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n    callback();\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode\n\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n    callback();\n  });\n}\n\nmodule.exports = MessageStream;","map":{"version":3,"sources":["/home/devansh/Desktop/ADS/final/node_modules/mongodb/lib/cmap/message_stream.js"],"names":["Duplex","require","BufferList","MongoParseError","decompress","Response","BinMsg","MongoError","OP_COMPRESSED","opcodes","OP_MSG","MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","compress","compressorIDs","uncompressibleCommands","Msg","kDefaultMaxBsonMessageSize","kBuffer","Symbol","MessageStream","constructor","options","bson","maxBsonMessageSize","_write","chunk","_","callback","buffer","append","length","sizeOfMessage","readInt32LE","messageBuffer","slice","consume","processMessage","_read","writeCommand","command","operationDescription","shouldCompress","agreedCompressor","canCompress","data","toBin","push","Array","isArray","Buffer","concat","concatenatedOriginalCommandBuffer","messageToBeCompressed","originalCommandOpCode","err","compressedMessage","cb","msgHeader","alloc","writeInt32LE","requestId","compressionDetails","writeUInt8","commandDoc","query","commandName","Object","keys","has","stream","message","messageHeader","responseTo","opCode","ResponseType","responseOptions","messageBody","emit","fromCompressed","compressorID","compressedBuffer","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Duplex = require('stream').Duplex;\nconst BufferList = require('bl');\nconst MongoParseError = require('../core/error').MongoParseError;\nconst decompress = require('../core/wireprotocol/compression').decompress;\nconst Response = require('../core/connection/commands').Response;\nconst BinMsg = require('../core/connection/msg').BinMsg;\nconst MongoError = require('../core/error').MongoError;\nconst OP_COMPRESSED = require('../core/wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../core/wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../core/wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst COMPRESSION_DETAILS_SIZE = require('../core/wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\nconst opcodes = require('../core/wireprotocol/shared').opcodes;\nconst compress = require('../core/wireprotocol/compression').compress;\nconst compressorIDs = require('../core/wireprotocol/compression').compressorIDs;\nconst uncompressibleCommands = require('../core/wireprotocol/compression').uncompressibleCommands;\nconst Msg = require('../core/connection/msg').Msg;\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\nconst kBuffer = Symbol('buffer');\n\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n */\nclass MessageStream extends Duplex {\n  constructor(options) {\n    options = options || {};\n    super(options);\n\n    this.bson = options.bson;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n\n    this[kBuffer] = new BufferList();\n  }\n\n  _write(chunk, _, callback) {\n    const buffer = this[kBuffer];\n    buffer.append(chunk);\n\n    while (buffer.length >= 4) {\n      const sizeOfMessage = buffer.readInt32LE(0);\n      if (sizeOfMessage < 0) {\n        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n        return;\n      }\n\n      if (sizeOfMessage > this.maxBsonMessageSize) {\n        callback(\n          new MongoParseError(\n            `Invalid message size: ${sizeOfMessage}, max allowed: ${this.maxBsonMessageSize}`\n          )\n        );\n        return;\n      }\n\n      if (sizeOfMessage > buffer.length) {\n        callback();\n        return;\n      }\n\n      const messageBuffer = buffer.slice(0, sizeOfMessage);\n      buffer.consume(sizeOfMessage);\n\n      processMessage(this, messageBuffer, callback);\n    }\n  }\n\n  _read(/* size */) {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;\n    if (!shouldCompress || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    }\n\n    // otherwise, compress the message\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n    // Extract information needed for OP_COMPRESSED from the uncompressed message\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n    // Compress the message body\n    compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err) {\n        operationDescription.cb(err, null);\n        return;\n      }\n\n      // Create the msgHeader of OP_COMPRESSED\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(\n        MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\n        0\n      ); // messageLength\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n      msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n\n      // Create the compression details of OP_COMPRESSED\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n      compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n}\n\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processMessage(stream, message, callback) {\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n\n  let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  const responseOptions = stream.responseOptions;\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit(\n      'message',\n      new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions)\n    );\n\n    callback();\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n\n  decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(\n        new MongoError(\n          'Decompressing a compressed message from the server failed. The message is corrupt.'\n        )\n      );\n\n      return;\n    }\n\n    stream.emit(\n      'message',\n      new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions)\n    );\n\n    callback();\n  });\n}\n\nmodule.exports = MessageStream;\n"]},"metadata":{},"sourceType":"script"}