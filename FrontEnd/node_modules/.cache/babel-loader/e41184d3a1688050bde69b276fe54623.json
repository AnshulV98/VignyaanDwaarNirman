{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst MessageStream = require('./message_stream');\n\nconst MongoError = require('../core/error').MongoError;\n\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\n\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\n\nconst CommandResult = require('../core/connection/command_result');\n\nconst StreamDescription = require('./stream_description').StreamDescription;\n\nconst wp = require('../core/wireprotocol');\n\nconst apm = require('../core/connection/apm');\n\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\n\nconst uuidV4 = require('../core/utils').uuidV4;\n\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n    this.monitorCommands = typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = Date.now(); // retain a reference to an `AutoEncrypter` if present\n\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    } // setup parser stream and message handling\n\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    stream.on('close', () => {\n      if (this.closed) {\n        return;\n      }\n\n      this.closed = true;\n      this[kQueue].forEach(op => op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`)));\n      this[kQueue].clear();\n      this.emit('close');\n    });\n    stream.on('timeout', () => {\n      if (this.closed) {\n        return;\n      }\n\n      stream.destroy();\n      this.closed = true;\n      this[kQueue].forEach(op => op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} timed out`)));\n      this[kQueue].clear();\n      this.emit('close');\n    }); // hook the message stream up to the passed in stream\n\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  } // the `connect` method stores the result of the handshake ismaster on the connection\n\n\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kIsMaster] = response;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime() {\n    return Date.now() - this[kLastUseTime];\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = Date.now();\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(err => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  } // Wire protocol methods\n\n\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n} /// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\n\n\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: {\n        write: write.bind(connection),\n        isConnected: () => true\n      }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    conn[kQueue].delete(message.responseTo);\n    const callback = operationDescription.cb;\n\n    if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    } // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n\n    callback(undefined, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n} // Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\n\n\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operationDescription.started = process.hrtime();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit('commandFailed', new apm.CommandFailedEvent(this, command, err, operationDescription.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit('commandFailed', new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));\n        } else {\n          this.emit('commandSucceeded', new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection\n};","map":{"version":3,"sources":["/home/devansh/Desktop/ADS/final/node_modules/mongodb/lib/cmap/connection.js"],"names":["EventEmitter","require","MessageStream","MongoError","MongoNetworkError","MongoWriteConcernError","CommandResult","StreamDescription","wp","apm","updateSessionFromResponse","uuidV4","kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kIsMaster","kAutoEncrypter","Connection","constructor","stream","options","id","address","streamIdentifier","bson","socketTimeout","monitorCommands","closed","destroyed","generation","Date","now","autoEncrypter","Map","on","messageHandler","forEach","op","cb","clear","emit","destroy","pipe","description","ismaster","response","receiveResponse","idleTime","clusterTime","markAvailable","callback","Object","assign","force","end","err","command","ns","cmd","makeServerTrampoline","query","cursorState","getMore","batchSize","killCursors","insert","ops","update","remove","connection","server","s","pool","write","bind","isConnected","conn","message","has","responseTo","operationDescription","get","delete","socketTimeoutOverride","setTimeout","parse","documents","document","session","$clusterTime","writeConcernError","ok","$err","errmsg","code","undefined","fullResult","remoteAddress","remotePort","toString","requestId","noResponse","documentsReturnedIn","promoteLongs","promoteValues","promoteBuffers","raw","compressor","agreedCompressor","zlibCompressionLevel","CommandStartedEvent","started","process","hrtime","reply","CommandFailedEvent","result","CommandSucceededEvent","set","writeCommand","e","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst MessageStream = require('./message_stream');\nconst MongoError = require('../core/error').MongoError;\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\nconst CommandResult = require('../core/connection/command_result');\nconst StreamDescription = require('./stream_description').StreamDescription;\nconst wp = require('../core/wireprotocol');\nconst apm = require('../core/connection/apm');\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\nconst uuidV4 = require('../core/utils').uuidV4;\n\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n    this.monitorCommands =\n      typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = Date.now();\n\n    // retain a reference to an `AutoEncrypter` if present\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    }\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    stream.on('close', () => {\n      if (this.closed) {\n        return;\n      }\n\n      this.closed = true;\n      this[kQueue].forEach(op =>\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`))\n      );\n      this[kQueue].clear();\n\n      this.emit('close');\n    });\n\n    stream.on('timeout', () => {\n      if (this.closed) {\n        return;\n      }\n\n      stream.destroy();\n      this.closed = true;\n      this[kQueue].forEach(op =>\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} timed out`))\n      );\n      this[kQueue].clear();\n\n      this.emit('close');\n    });\n\n    // hook the message stream up to the passed in stream\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  }\n\n  // the `connect` method stores the result of the handshake ismaster on the connection\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kIsMaster] = response;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime() {\n    return Date.now() - this[kLastUseTime];\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = Date.now();\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  // Wire protocol methods\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n}\n\n/// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: { write: write.bind(connection), isConnected: () => true }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    conn[kQueue].delete(message.responseTo);\n\n    const callback = operationDescription.cb;\n    if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    }\n\n    // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n    callback(\n      undefined,\n      new CommandResult(\n        operationDescription.fullResult ? message : message.documents[0],\n        conn,\n        message\n      )\n    );\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n}\n\n// Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n\n    operationDescription.started = process.hrtime();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit(\n          'commandFailed',\n          new apm.CommandFailedEvent(this, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit(\n            'commandFailed',\n            new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started)\n          );\n        } else {\n          this.emit(\n            'commandSucceeded',\n            new apm.CommandSucceededEvent(this, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection\n};\n"]},"metadata":{},"sourceType":"script"}